import * as z from "zod";
import type { Account } from "thirdweb/wallets";
import type { Hex, ThirdwebClient } from "thirdweb";
import { awsKmsPlugin } from "./plugins/aws-kms";
import { getConnectedSmartWallet } from "../../../server/utils/wallets/create-smart-wallet";
import {
  DEFAULT_ACCOUNT_FACTORY_V0_7,
  ENTRYPOINT_ADDRESS_v0_7,
} from "thirdweb/wallets/smart";
import { prisma } from "../../db/client";
import { decrypt, encrypt } from "../../utils/crypto";

type LegacyWalletDetailFields = {
  awsKmsKeyId: string | null;
  awsKmsArn: string | null;
  awsKmsSecretAccessKey: string | null;
  awsKmsAccessKeyId: string | null;

  gcpKmsKeyId: string | null;
  gcpKmsKeyRingId: string | null;
  gcpKmsKeyVersionId: string | null;
  gcpKmsLocationId: string | null;
  gcpKmsResourcePath: string | null;
  gcpApplicationCredentialEmail: string | null;
  gcpApplicationCredentialPrivateKey: string | null;
};

export function defineAccountPlugin<
  TType extends string,
  TConfig extends z.ZodType,
  TPlatformIdentifiers extends z.ZodType,
  TCredentialData extends {
    schema: z.ZodType;
    encryptedKeys: readonly (keyof z.infer<TCredentialData["schema"]>)[];
  },
  TCreate extends z.ZodObject<{
    label: z.ZodString;
    credentialId: z.ZodOptionalType<z.ZodString>;
    [k: string]: z.ZodType;
  }>,
  TLegacyConfig extends z.ZodType | undefined = undefined,
>({
  type,
  schemas,
  implementation,
}: {
  type: TType;
  schemas: {
    config: TConfig;
    legacyConfig: TLegacyConfig;
    platformIdentifiers: TPlatformIdentifiers;
    credentialData: TCredentialData;
    create: TCreate;
  };
  implementation: {
    /**
     * Provision an EOA account of the plugin type
     * @param params.config - Configuration parsed from the schema defined by the plugin at schema.config; config is parsed at server startup from global config in the database
     * @param params.input - Input data for provisioning the account, typeof schemas.create defined by the plugin
     * @param params.legacyConfig - Legacy configuration parsed from the schema defined by the plugin at schema.legacyConfig; legacyConfig is parsed at server startup from global config in the database. Instead of reading from config.walletProviderConfigs, it reads from config at root level. This is deprecated and only preserved for backwards compatibility.
     * @returns Object containing the provisioned account and platform identifiers. Platform identifiers are stored in the DB, and are used to reconstruct the account.
     */
    provisionAccount: (params: {
      config: z.infer<TConfig>;
      legacyConfig: TLegacyConfig extends z.ZodType
        ? z.infer<TLegacyConfig>
        : undefined;
      input: z.infer<TCreate>;
      credential: z.infer<TCredentialData["schema"]> | undefined;
      client: ThirdwebClient;
    }) => Promise<{
      account: Account;
      platformIdentifiers: z.infer<TPlatformIdentifiers>;
    }>;

    /**
     * Get an EOA account.
     * @param params.config - Configuration parsed from the schema defined by the plugin at schema.config; config is parsed at server startup from global config in the database
     * @param params.platformIdentifiers - Platform identifiers are retreived from DB, and were generated by the plugin's provision method when the wallet was created
     * @param params.type - The type of the wallet, eg: "aws-kms", "gcp-kms", "local"
     * @param legacyFields - Legacy fields that might be needed to reconstruct the account. These are only available to read for legacy wallets, cannot be used to create a new account. These will be removed in the future.
     * @param credential - The credential data for the wallet, if any. Legacy wallets might not have a credential, and will need to rely on legacyFields, or even optionally on the config to reconstruct the account.
     * @returns the EOA account from the provided identifiers
     */
    getAccount: (params: {
      config: z.infer<typeof schemas.config>;
      legacyConfig: TLegacyConfig extends z.ZodType
        ? z.infer<TLegacyConfig>
        : undefined;
      platformIdentifiers?: z.infer<typeof schemas.platformIdentifiers>;
      credential?: z.infer<typeof schemas.credentialData.schema>;
      legacyFields: LegacyWalletDetailFields;
      client: ThirdwebClient;
    }) => Promise<Account>;
  };
}) {
  const smartType = `smart:${type}` as const;

  return {
    type,
    smartType,
    schemas: {
      ...schemas,
      createSmart: schemas.create.extend({
        type: z.literal(smartType),
      }),
    },
    implementation,
  } as const;
}

const ACCOUNT_PLUGINS = [awsKmsPlugin] as const;

// need to slice and spread because z.union wants to be sure of atleast 2 array members
const createAccountSchema = z.discriminatedUnion("type", [
  ACCOUNT_PLUGINS[0].schemas.create.extend({
    type: z.literal(ACCOUNT_PLUGINS[0].type),
  }),
  ACCOUNT_PLUGINS[0].schemas.create.extend({
    type: z.literal(`smart:${ACCOUNT_PLUGINS[0].type}` as const),
  }),
  ...ACCOUNT_PLUGINS.slice(1).flatMap((plugin) => [
    plugin.schemas.create.extend({
      type: z.literal(plugin.type),
    }),
    plugin.schemas.create.extend({
      type: z.literal(`smart:${plugin.type}` as const),
    }),
  ]),
]);

// need to slice and spread because z.union wants to be sure of atleast 2 array members
const createCredentialSchema = z.discriminatedUnion("type", [
  ACCOUNT_PLUGINS[0].schemas.credentialData.schema.extend({
    type: z.literal(ACCOUNT_PLUGINS[0].type),
    label: z.string(),
  }),
  ...ACCOUNT_PLUGINS.slice(1).map((plugin) =>
    plugin.schemas.credentialData.schema.extend({
      type: z.literal(plugin.type),
      label: z.string(),
    }),
  ),
]);

// type WalletType =
//   | (typeof ACCOUNT_PLUGINS)[number]["type"]
//   | `smart:${(typeof ACCOUNT_PLUGINS)[number]["type"]}`;

type PluginTuple = typeof ACCOUNT_PLUGINS;
type Plugin = PluginTuple[number];
type WalletType = Plugin["type"] | `smart:${Plugin["type"]}`;

type PluginConfigMap<P extends Plugin> = {
  plugin: P;
  config: z.infer<P["schemas"]["config"]>;
  legacyConfig: P["schemas"] extends { legacyConfig: z.ZodType }
    ? z.infer<P["schemas"]["legacyConfig"]>
    : undefined;
};

type PluginRegistry = {
  [P in Plugin as P["type"] | `smart:${P["type"]}`]: PluginConfigMap<P>;
};

class AccountService {
  private plugins: PluginRegistry;
  private client: ThirdwebClient;

  constructor(globalConfig: Record<string, unknown>, client: ThirdwebClient) {
    this.client = client;

    this.plugins = ACCOUNT_PLUGINS.reduce<PluginRegistry>((acc, plugin) => {
      const entry = {
        plugin,
        config: plugin.schemas.config.parse(
          globalConfig.walletProviderConfigs ?? {},
        ),
        legacyConfig: plugin.schemas.legacyConfig?.parse(globalConfig),
      } satisfies PluginConfigMap<typeof plugin>;

      return {
        // biome-ignore lint/performance/noAccumulatingSpread: need to spread for typesafety
        ...acc,
        [plugin.type]: entry,
        [plugin.smartType]: entry,
      };
    }, {} as PluginRegistry);
  }

  async create(input: z.infer<typeof createAccountSchema>) {
    const { plugin, config, legacyConfig } = this.plugins[input.type];

    let credential:
      | z.infer<typeof plugin.schemas.credentialData.schema>
      | undefined;

    if (input.credentialId) {
      const untypedCredential = await this.getCredential(input.credentialId);
      credential = plugin.schemas.credentialData.schema.parse(
        untypedCredential.data,
      );
    }

    const { account, platformIdentifiers } =
      await plugin.implementation.provisionAccount({
        config,
        legacyConfig,
        input,
        credential,
        client: this.client,
      });

    if (input.type.startsWith("smart:")) {
      const smartAccount = await getConnectedSmartWallet({
        adminAccount: account,
        accountFactoryAddress: DEFAULT_ACCOUNT_FACTORY_V0_7,
        entrypointAddress: ENTRYPOINT_ADDRESS_v0_7,
      });

      await prisma.walletDetails.create({
        data: {
          address: smartAccount.address.toLowerCase(),
          type: input.type,
          label: input.label,
          credentialId: input.credentialId,
          platformIdentifiers,
          accountSignerAddress: account.address.toLowerCase(),
          accountFactoryAddress: DEFAULT_ACCOUNT_FACTORY_V0_7,
          entrypointAddress: ENTRYPOINT_ADDRESS_v0_7,
        },
      });

      return { account: smartAccount, adminAccount: account };
    }

    await prisma.walletDetails.create({
      data: {
        address: account.address.toLowerCase(),
        type: input.type,
        label: input.label,
        credentialId: input.credentialId,
        platformIdentifiers,
      },
    });

    return { account };
  }

  async createCredential(input: z.infer<typeof createCredentialSchema>) {
    const { plugin } = this.plugins[input.type];

    // Handle encryption for specified fields
    const data = { ...input };
    for (const key of plugin.schemas.credentialData.encryptedKeys) {
      if (key in data) {
        data[key] = encrypt(data[key]);
      }
    }

    return prisma.walletCredentials.create({
      data: {
        type: input.type,
        label: input.label,
        data,
      },
    });
  }

  async getCredential(credentialId: string) {
    const credential = await prisma.walletCredentials.findUnique({
      where: { id: credentialId },
      select: {
        id: true,
        type: true,
        label: true,
        data: true,
      },
    });

    if (!credential) {
      throw new Error(`Credential not found: ${credentialId}`);
    }

    const plugin = this.plugins[credential.type as WalletType].plugin;

    if (!plugin) {
      throw new Error(`Credential type not found: ${credential.type}`);
    }

    // Decrypt specified fields
    const data = credential.data?.valueOf();
    if (typeof data !== "object") throw new Error("Invalid credential data");

    const parsedCredentialData =
      plugin.schemas.credentialData.schema.parse(data);

    for (const key of plugin.schemas.credentialData.encryptedKeys) {
      if (key in parsedCredentialData) {
        parsedCredentialData[key] = decrypt(parsedCredentialData[key]);
      }
    }

    return {
      ...credential,
      data,
    };
  }

  async getAccount(address: string) {
    const walletDetails = await prisma.walletDetails.findUnique({
      where: {
        address: address.toLowerCase(),
      },
    });

    if (!walletDetails) {
      throw new Error(`Wallet details not found: ${address}`);
    }

    const { plugin, config, legacyConfig } =
      this.plugins[walletDetails.type as WalletType];

    let credential:
      | z.infer<typeof plugin.schemas.credentialData.schema>
      | undefined;

    if (walletDetails.credentialId) {
      const untypedCredential = await this.getCredential(
        walletDetails.credentialId,
      );
      credential = plugin.schemas.credentialData.schema.parse(
        untypedCredential.data,
      );
    }

    const untypedPlatformIdentifiers = walletDetails.platformIdentifiers;

    const platformIdentifiers = plugin.schemas.platformIdentifiers.parse(
      untypedPlatformIdentifiers,
    );

    const account = await plugin.implementation.getAccount({
      config,
      legacyConfig,
      platformIdentifiers,
      credential: credential,
      legacyFields: walletDetails,
      client: this.client,
    });

    if (!walletDetails.type.startsWith("smart:")) {
      return { account };
    }

    if (
      !walletDetails.accountFactoryAddress ||
      !walletDetails.entrypointAddress
    ) {
      throw new Error(
        `Smart wallet details missing accountFactoryAddress or entrypointAddress: ${address}`,
      );
    }

    const smartAccount = await getConnectedSmartWallet({
      adminAccount: account,
      accountFactoryAddress: walletDetails.accountFactoryAddress as Hex,
      entrypointAddress: walletDetails.entrypointAddress as Hex,
    });

    return { account: smartAccount, adminAccount: account };
  }
}

export type { WalletType };
export { createAccountSchema, createCredentialSchema, AccountService };
